@doc An HTTP caching library

`http_cache' is a stateless Erlang HTTP caching library that implements the various
HTTP RFCs related to caching.

== Modules ==

{@link http_cache} exposes functions to cache backend responses, get cached responses
whenever they can be served, and invalidate previously stored responses.

{@link http_cache_store} is the behaviour to be implemented by stores.

{@link http_cache_store_process} is an example store that stores cached responses in
the current process and is mainly used for testing purpose.

== Stores ==

This library being stateless, it cannot be used in production and a real, non-test store
is needed.
<a href="https://github.com/tanguilp/http_cache_store_native">http_cache_store_native</a> is such a store. It uses ETS as a backend and is cluster-aware.

== Best practices ==

== Telemetry events ==

All time measurements are in microseconds.

The following events are emitted by `http_cache':
<ul>
  <li>
    `[http_cache, lookup]' when {@link http_cache:get/2} is called.

    Measurements:
    <ul>
      <li>`total_time': the total time of the lookup</li>
      <li>`store_lookup_time': time taken to query the store for suitable responses</li>
      <li>`response_selection_time': time to select the best response among suitable
      responses. A high value can indicate the presence of too many variants</li>
      <li>`candidate_count': the number of candidate responses that are returned by the
      store. A high value can indicate the presence of too many variants</li>
      <li>`decompress_time': time spend decompressing the response</li>
      <li>`range_time': time spend constructing a range response</li>
    </ul>

    Tags:
    <ul>
      <li>`freshness': one of {@link http_cache:freshness()}</li>
    </ul>
  </li>
  <li>
    `[http_cache, cache]' when {@link http_cache:cache/3} is called.

    Measurements:
    <ul>
      <li>`total_time': the total time of the lookup</li>
      <li>`store_save_time': time taken to save the response into the store</li>
      <li>`compress_time': time spend compressing the response. This happens when the
      `auto_compress' option is used</li>
      <li>`decompress_time': time spend decompressing the response. This happens when the
      `auto_compress' option is used but the client does not support compression and
      the result, stored compressed, has to be returned uncompressed</li>
      <li>`range_time': time spend constructing a range response</li>
    </ul>

    Tags:
    <ul>
      <li>`cacheable': `true' if the response was cacheable (and cached), `false' otherwise</li>
    </ul>
  </li>
  <li>
    `[http_cache, invalidation]' when {@link http_cache:invalidate_url/2} or
    {@link http_cache:invalidate_by_alternate_key/2} is called.

    Measurements:
    <ul>
      <li>`duration': the time it took to invalidate entries</li>
      <li>`count': the number of entries invalidated. If the store does not support
      returning the number of invalidated entries, the value is set to `1'</li>
    </ul>

    Tags:
    <ul>
      <li>`type': `url' or `alternate_key'</li>
    </ul>
  </li>
  <li>
    `[http_cache, compress_operation]' whenever a compress operation is performed on an
    HTTP response.

    Measurements:
    <ul>
      <li>`duration': the time it took to compress a response</li>
    </ul>

    Tags:
    <ul>
      <li>`alg': `gzip' (which is the only supported algorithm at the moment)</li>
    </ul>
  </li>
  <li>
    `[http_cache, decompress_time]' whenever a decompress operation is performed on an
    HTTP response.

    Measurements:
    <ul>
      <li>`duration': the time it took to decompress a response</li>
    </ul>

    Tags:
    <ul>
      <li>`alg': `gzip' (which is the only supported algorithm at the moment)</li>
    </ul>
  </li>
</ul>
